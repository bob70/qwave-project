-- File: controller.vhd
-- Generated by MyHDL 0.7
-- Date: Thu May  9 20:55:50 2013



package pck_controller is

    type t_enum_tCtrlStates_1 is (
    INIT0,
    INIT1,
    IDLE,
    SET_VREF0,
    SET_VREF1,
    SET_VLOG0,
    SET_VLOG1,
    SET_ATTENUATORS,
    SET_COUPLINGS,
    SET_DECIMATION,
    SET_ANALOGTRIGGER,
    SET_DIGITALTRIGGER,
    DUMP_DATA_INT1,
    DUMP_DATA_INT2,
    DUMP_DATA0,
    DUMP_DATA1,
    DUMP_DATA2,
    DUMP_DATA3,
    DUMP_DATA4,
    DUMP_DATA_PREPFT,
    START_CAPTURE,
    CAPTURE,
    READ_COMMAND,
    READ_CMD_DATA,
    DECODE_CMD,
    REQUEST_RESEND0,
    REQUEST_RESEND1,
    REQUEST_RESEND2,
    SEND_ACKNOWLEDGE0,
    SEND_ACKNOWLEDGE1,
    SEND_ACKNOWLEDGE2,
    PREPARE_ADC
);

end package pck_controller;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_07.all;

use work.pck_controller.all;

entity controller is
    port (
        clk: in std_logic;
        reset: in std_logic;
        ft245din: out unsigned(7 downto 0);
        ft245dout: in unsigned(7 downto 0);
        ft245rw: out std_logic;
        ft245busy: in std_logic;
        ft245oe: in std_logic;
        ft245wr: in std_logic;
        ft245dataWaitIn: out std_logic;
        ft245dataWaitOut: in std_logic;
        ft245strobe: out std_logic;
        ft245reset: out std_logic;
        dacReset: out std_logic;
        dacVrefTopA: out unsigned(7 downto 0);
        dacVrefTopB: out unsigned(7 downto 0);
        dacVrefBotA: out unsigned(7 downto 0);
        dacVrefBotB: out unsigned(7 downto 0);
        dacStrobe: out std_logic;
        dacBusy: in std_logic;
        digipotReset: out std_logic;
        digipotValue: out unsigned(6 downto 0);
        digipotStrobe: out std_logic;
        digipotBusy: in std_logic;
        bufferReset: out std_logic;
        bufferDataOut: in unsigned(31 downto 0);
        bufferDataIn: out unsigned(31 downto 0);
        bufferReady: in std_logic;
        bufferOutputInputReady: out std_logic;
        bufferAllowWriteOverlap: inout std_logic;
        bufferDataDirection: out std_logic;
        decimatorNewValueFlag: out std_logic;
        decimationRatioBase: out unsigned(3 downto 0);
        decimationStyle: out unsigned(1 downto 0);
        decimator1out: in unsigned(7 downto 0);
        decimator2out: in unsigned(7 downto 0);
        trigger1Type: out std_logic;
        trigger1Slope: out std_logic;
        analogTrigger1Reset: out std_logic;
        trigger1Value: out unsigned(7 downto 0);
        analog1Trigger: in std_logic;
        trigger2Type: out std_logic;
        trigger2Slope: out std_logic;
        analogTrigger2Reset: out std_logic;
        trigger2Value: out unsigned(7 downto 0);
        analog2Trigger: in std_logic;
        digitalTriggerReset: out std_logic;
        triggerPattern: out unsigned(63 downto 0);
        triggerSamples: out unsigned(1 downto 0);
        digiTrigger: in std_logic;
        adc1pd: out std_logic;
        adc2pd: out std_logic;
        adc1relatt: out std_logic;
        adc2relatt: out std_logic;
        adc1relco: out std_logic;
        adc2relco: out std_logic;
        led0: inout std_logic;
        led1: inout std_logic;
        logicAnalyzer: in unsigned(15 downto 0);
        la1dir: out std_logic;
        la2dir: out std_logic;
        la1oe: out std_logic;
        la2oe: out std_logic;
        fastClk: in std_logic
    );
end entity controller;
-- Main DSO controller.
-- clk - clock 60MHz from FTDI
-- reset - asynchronous reset
-- ft245* respective FT245 interfaces
-- dac* respective dac interfaces
-- digipot* respective digipot interfaces
-- buffer* respective buffer interfaces
-- decim* respective decimators interfaces
-- trigger* triggers interfaces
-- adc1pd - power down of ADC1
-- adc2pd - power down of ACC2
-- adc1relatt - relay of ADC1 attenuator
-- adc2relatt - relay of ADC2 attenuator
-- adc1relco - relay of ADC1 coupling
-- adc2relco - relay of ADC2 coupling
-- led0 - info LED 0
-- led1 - info LED 1
-- logicAnalyzer - data from logic analyzer decimator
-- la* interface of logic analyzer transciever
-- fastClk - 125MHz clock from ADC oscillator
-- 
-- Commnnication protocol:
--  Commands:
--  Bit lengths        | 8bit                 | 72bit     |   
--  Field description  | Message number       | Data      | 
-- 
--  RESET              | 0x00                 | DON'T CARE
--  SET_VREF           | 0x10                 | 8bit - TopA, 8bit - BotA, 8bit - TopB, 8bit - BotB
--  SET_VLOG           | 0x11                 | 8bit - 7bit - value
--  SET_ATTENUATORS    | 0x20                 | 8bit - 1bit - att. relay ADC1, 8bit - 1bit att. relay ADC2
--  SET_COUPLINGS      | 0x21                 | 1bit - ac/dc relay ADC1, 1bit ac/dc relay ADC2
--  SET_DECIMATION     | 0x30                 | 8bit - 4bit - decimationRatioBase, 8bit -2bit - decimationStyle
--  SET_ANALOGTRIGGER  | 0x31                 | Trigger adc1: 8bit - value, 8bit -  1bit - triggerType, 1bit - slope | 
--                                              Trigger adc2: 8bit - value, 8bit - 1bit - triggerType, 1bit - slope
--  SET_DIGITALTRIGGER | 0x32                 | 64bit - pattern, 2bit - samples
--  START_CAPTURE      | 0x40                 | 8bit - channel selection
--                                              0x00 - analog1 only, 0x01 analog2 only, 0x02 analog1 + digi,
--                                              0x03 - analog2 + digi, 0x04 analog1+analog2, 0x05 an1+an2+dig
--                                              0x06 - dig only
--  Respones:
--  DATA_DUMP          | 0x50                 | burst of data (longer than 72bit) where first two bytes are respective ADC data and
--                                              second two bytes are data of logic analyzer
--  DATA_OK            | 0x80                 | DON'T CARE

architecture MyHDL of controller is

signal commandDataCounter: unsigned(3 downto 0);
signal holdoffCounter: unsigned(25 downto 0);
signal state: t_enum_tCtrlStates_1;
signal triggerConfiguration: unsigned(7 downto 0);
signal wait245: unsigned(1 downto 0);
signal nTrigger: std_logic;
signal commandData: unsigned(71 downto 0);
signal oldBufferData: unsigned(31 downto 0);
signal answerNumber: unsigned(1 downto 0);
signal responseCounter: unsigned(2 downto 0);
signal command: unsigned(7 downto 0);
signal preparationCycles: unsigned(7 downto 0);
signal backState: t_enum_tCtrlStates_1;

begin



-- This is state machine of main controller. 
-- After initialization in INIT0 and INIT1 controller
-- waits for indication of incoming data from ft245 controller (IDLE), 
-- when this happend data are read into command 
-- and commandData registers (READ_DATA and READ_CMD_DATA)
-- then command is decoded (DECODE_CMD) if successful 
-- acknowledge is sent back to PC(SEND_ACKNOWLEDGE0, 1 and 2),
-- if unexpected data is received then request for 
-- resend is sent to PC(REQUEST_RESEND0, 1 and 2).
-- Then appropriate command is executed, decimation, triggers, attenuators and couplings are
-- set directly. Voltage references and logic voltage are set to respective
-- controllers and controller waits until operation is complete.
-- When START_CAPTURE command is received then ADC power dows are released and ADCs are
-- activated this state (PREPARE_ADC) is held for 255 clock cycles to warm up ADCs 
-- (first 100-150 of ADC samples after power down is released are garbage).
-- then in START_CAPTURE transicever of logic analyzer is activated
-- and directed to input data from outer circuit to FPGA (by la* signals) and
-- buffer direction is set to WRITE and outputInputReady of buffer is set to HIGH.
-- (which makes buffer continualy input data from decimators).
-- Controller stays in CAPTURE state until buffer indicates that it is FULL by 
-- dropping bufferReady to LOW.
-- Then in state DUMP_DATA_PREPFT, controller is waiting until FT245 controller goes to IDLE state.
-- In state DUMP_DATA0 buffer is switched to READ mode and FT245 controller is switchet to WRITE mode.
-- In DUMP_DATA1 four bytes indicating dump of data are sent.
-- DUMP_DATA2 then outputs first byte of 32bit data packet, and puts bufferOutputInputReady to LOW.
-- DUMP_DATA_INT1 outputs second byte of 32bit data packet.
-- DUMP_DATA_INT2 outputs third byte of 32bit data packet
-- DUMP_DATA3 outputs fourth byte of 32bit data packet and puts bufferOutputInputReady
-- to HIGH getting next 32bit dat packet out of buffer.
-- DUMP_DATA4 is used to stop transmission when in any of DUMP_DATA2, DUMP_DATA_INT1, DUMP_DATA_INT2 or DUMP_DATA3
-- TXE goes high indicating full incoming buffer in FTDI chip. Then transmission must continue where it stopped
-- to make data incoming to PC consistent. 
CONTROLLER_FSM: process (clk, reset) is
begin
    if (reset = '1') then
        state <= INIT0;
        ft245reset <= '1';
        dacReset <= '1';
        bufferReset <= '1';
        digipotReset <= '1';
        analogTrigger1Reset <= '1';
        analogTrigger2Reset <= '1';
        digitalTriggerReset <= '1';
        adc1pd <= '1';
        adc2pd <= '1';
        adc1relatt <= '1';
        adc2relatt <= '1';
        adc1relco <= '1';
        adc2relco <= '1';
        led0 <= '0';
        led1 <= '1';
        commandDataCounter <= "0000";
        triggerConfiguration <= "00000000";
        la1dir <= '1';
        la2dir <= '1';
        la1oe <= '1';
        la2oe <= '1';
        answerNumber <= "00";
        responseCounter <= "000";
        preparationCycles <= "00000000";
    elsif rising_edge(clk) then
        case state is
            when INIT0 =>
                responseCounter <= "000";
                ft245reset <= '1';
                dacReset <= '1';
                bufferReset <= '1';
                digipotReset <= '1';
                analogTrigger1Reset <= '1';
                analogTrigger2Reset <= '1';
                digitalTriggerReset <= '1';
                adc1pd <= '1';
                adc2pd <= '1';
                adc1relatt <= '1';
                adc2relatt <= '1';
                adc1relco <= '1';
                adc2relco <= '1';
                led0 <= '1';
                led1 <= '0';
                la1dir <= '1';
                la2dir <= '1';
                la1oe <= '1';
                la2oe <= '1';
                commandDataCounter <= "0000";
                triggerConfiguration <= "00000000";
                ft245strobe <= '0';
                ft245dataWaitIn <= '0';
                ft245rw <= '0';
                dacStrobe <= '0';
                digipotStrobe <= '0';
                bufferDataDirection <= '0';
                bufferOutputInputReady <= '0';
                decimationStyle <= "00";
                decimationRatioBase <= "0000";
                trigger1Value <= "01100100";
                trigger1Type <= '0';
                trigger1Slope <= '0';
                trigger2Value <= "01100100";
                trigger2Type <= '0';
                trigger2Slope <= '0';
                triggerPattern <= "0000000000000000000000000000000000000000000000000000000000000000";
                triggerSamples <= "00";
                state <= INIT1;
            when INIT1 =>
                led0 <= '1';
                led1 <= '1';
                ft245reset <= '0';
                dacReset <= '0';
                digipotReset <= '0';
                analogTrigger1Reset <= '0';
                analogTrigger2Reset <= '0';
                digitalTriggerReset <= '0';
                if (to_boolean(dacBusy) or to_boolean(digipotBusy)) then
                    state <= INIT1;
                    led0 <= '1';
                    led1 <= '1';
                else
                    state <= IDLE;
                    led0 <= '0';
                    led1 <= '0';
                end if;
            when IDLE =>
                bufferReset <= '1';
                preparationCycles <= "00000000";
                ft245rw <= '0';
                ft245strobe <= '1';
                ft245dataWaitIn <= '0';
                if (to_boolean(ft245busy) and (ft245oe = '0')) then
                    wait245 <= "00";
                    state <= READ_COMMAND;
                    ft245strobe <= '0';
                else
                    state <= IDLE;
                end if;
            when READ_COMMAND =>
                if (ft245oe = '0') then
                    if (wait245 < 1) then
                        wait245 <= (wait245 + 1);
                        command <= ft245dout;
                    else
                        wait245 <= "00";
                        state <= READ_CMD_DATA;
                        commandDataCounter <= "0000";
                    end if;
                else
                    state <= IDLE;
                end if;
            when READ_CMD_DATA =>
                if (ft245oe = '0') then
                    if (commandDataCounter < 8) then
                        commandDataCounter <= (commandDataCounter + 1);
                    end if;
                    case commandDataCounter is
                        when "0000" =>
                            commandData(72-1 downto 64) <= ft245dout;
                        when "0001" =>
                            commandData(64-1 downto 56) <= ft245dout;
                        when "0010" =>
                            commandData(56-1 downto 48) <= ft245dout;
                        when "0011" =>
                            commandData(48-1 downto 40) <= ft245dout;
                        when "0100" =>
                            commandData(40-1 downto 32) <= ft245dout;
                        when "0101" =>
                            commandData(32-1 downto 24) <= ft245dout;
                        when "0110" =>
                            commandData(24-1 downto 16) <= ft245dout;
                        when "0111" =>
                            commandData(16-1 downto 8) <= ft245dout;
                        when others => -- "1000"
                            commandData(8-1 downto 0) <= ft245dout;
                            state <= DECODE_CMD;
                    end case;
                else
                    led0 <= to_std_logic((not to_boolean(led0)));
                    if (commandDataCounter > 2) then
                        state <= DECODE_CMD;
                    else
                        state <= REQUEST_RESEND0;
                    end if;
                end if;
            when DECODE_CMD =>
                case command is
                    when "10101110" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00010000" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00010001" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00100000" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00100001" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00110000" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00110001" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "00110010" =>
                        state <= SEND_ACKNOWLEDGE0;
                    when "01000000" =>
                        state <= PREPARE_ADC;
                    when "10101010" =>
                        state <= IDLE;
                    when others =>
                        state <= REQUEST_RESEND0;
                        led0 <= to_std_logic((not to_boolean(led0)));
                        led1 <= to_std_logic((not to_boolean(led1)));
                end case;
            when SEND_ACKNOWLEDGE0 =>
                if to_boolean(ft245busy) then
                    state <= SEND_ACKNOWLEDGE0;
                else
                    state <= SEND_ACKNOWLEDGE1;
                end if;
            when SEND_ACKNOWLEDGE1 =>
                ft245rw <= '1';
                responseCounter <= "000";
                ft245din <= "10000000";
                if (ft245wr = '0') then
                    state <= SEND_ACKNOWLEDGE2;
                    ft245strobe <= '0';
                else
                    ft245strobe <= '1';
                    state <= SEND_ACKNOWLEDGE1;
                end if;
            when SEND_ACKNOWLEDGE2 =>
                if (responseCounter < 1) then
                    responseCounter <= (responseCounter + 1);
                    ft245din <= "10000000";
                    state <= SEND_ACKNOWLEDGE2;
                else
                    responseCounter <= "000";
                    case command is
                        when "10101110" =>
                            state <= INIT0;
                        when "00010000" =>
                            state <= SET_VREF0;
                        when "00010001" =>
                            state <= SET_VLOG0;
                        when "00100000" =>
                            state <= SET_ATTENUATORS;
                        when "00100001" =>
                            state <= SET_COUPLINGS;
                        when "00110000" =>
                            state <= SET_DECIMATION;
                        when "00110001" =>
                            state <= SET_ANALOGTRIGGER;
                        when "00110010" =>
                            state <= SET_DIGITALTRIGGER;
                        when "01000000" =>
                            state <= START_CAPTURE;
                        when others =>
                            state <= IDLE;
                    end case;
                end if;
            when REQUEST_RESEND0 =>
                state <= IDLE;
                if to_boolean(ft245busy) then
                    state <= REQUEST_RESEND0;
                else
                    state <= REQUEST_RESEND1;
                end if;
            when REQUEST_RESEND1 =>
                ft245rw <= '1';
                responseCounter <= "000";
                ft245din <= "10010000";
                if (ft245wr = '0') then
                    state <= REQUEST_RESEND2;
                    ft245strobe <= '0';
                else
                    ft245strobe <= '1';
                    state <= REQUEST_RESEND1;
                end if;
            when REQUEST_RESEND2 =>
                if (responseCounter < 1) then
                    responseCounter <= (responseCounter + 1);
                    ft245din <= "10010000";
                    state <= REQUEST_RESEND2;
                else
                    responseCounter <= "000";
                    ft245dataWaitIn <= '1';
                    ft245rw <= '0';
                    state <= IDLE;
                end if;
            when SET_VREF0 =>
                dacVrefTopA <= commandData(72-1 downto 64);
                dacVrefBotA <= commandData(64-1 downto 56);
                dacVrefTopB <= commandData(56-1 downto 48);
                dacVrefBotB <= commandData(48-1 downto 40);
                if to_boolean(dacBusy) then
                    dacStrobe <= '0';
                    state <= SET_VREF1;
                else
                    state <= SET_VREF0;
                    dacStrobe <= '1';
                end if;
            when SET_VREF1 =>
                if to_boolean(dacBusy) then
                    state <= SET_VREF1;
                else
                    led1 <= to_std_logic((not to_boolean(led1)));
                    state <= IDLE;
                end if;
            when SET_VLOG0 =>
                digipotValue <= commandData(72-1 downto 65);
                if to_boolean(digipotBusy) then
                    digipotStrobe <= '0';
                    state <= SET_VLOG1;
                else
                    digipotStrobe <= '1';
                    state <= SET_VLOG0;
                end if;
            when SET_VLOG1 =>
                if to_boolean(digipotBusy) then
                    state <= SET_VLOG1;
                else
                    state <= IDLE;
                end if;
            when SET_ATTENUATORS =>
                led1 <= to_std_logic((not to_boolean(led1)));
                adc1relatt <= commandData(71);
                adc2relatt <= commandData(63);
                state <= IDLE;
            when SET_COUPLINGS =>
                led1 <= to_std_logic((not to_boolean(led1)));
                adc1relco <= commandData(71);
                adc2relco <= commandData(63);
                state <= IDLE;
            when SET_DECIMATION =>
                decimationRatioBase <= commandData(68-1 downto 64);
                decimationStyle <= commandData(58-1 downto 56);
                state <= IDLE;
            when SET_ANALOGTRIGGER =>
                trigger1Value <= commandData(72-1 downto 64);
                trigger1Type <= commandData(63);
                trigger1Slope <= commandData(62);
                trigger2Value <= commandData(56-1 downto 48);
                trigger2Type <= commandData(47);
                trigger2Slope <= commandData(46);
                state <= IDLE;
            when SET_DIGITALTRIGGER =>
                triggerPattern <= commandData(72-1 downto 8);
                triggerSamples <= commandData(8-1 downto 6);
                state <= IDLE;
            when PREPARE_ADC =>
                bufferReset <= '1';
                triggerConfiguration <= commandData(72-1 downto 64);
                if ((triggerConfiguration = 0) or (triggerConfiguration = 2) or (triggerConfiguration = 4) or (triggerConfiguration = 5)) then
                    adc1pd <= '0';
                end if;
                if ((triggerConfiguration = 1) or (triggerConfiguration = 3) or (triggerConfiguration = 4) or (triggerConfiguration = 5)) then
                    adc2pd <= '0';
                end if;
                if (preparationCycles = 255) then
                    bufferReset <= '0';
                    state <= START_CAPTURE;
                    preparationCycles <= "00000000";
                else
                    state <= PREPARE_ADC;
                    preparationCycles <= (preparationCycles + 1);
                end if;
            when START_CAPTURE =>
                la1dir <= '0';
                la2dir <= '0';
                la1oe <= '0';
                la2oe <= '0';
                bufferOutputInputReady <= '1';
                bufferDataDirection <= '1';
                if to_boolean(bufferReady) then
                    state <= CAPTURE;
                else
                    state <= START_CAPTURE;
                end if;
            when CAPTURE =>
                if to_boolean(bufferReady) then
                    state <= CAPTURE;
                else
                    state <= DUMP_DATA_PREPFT;
                    bufferOutputInputReady <= '0';
                end if;
            when DUMP_DATA_PREPFT =>
                if to_boolean(ft245busy) then
                    state <= DUMP_DATA_PREPFT;
                else
                    state <= DUMP_DATA0;
                end if;
            when DUMP_DATA0 =>
                adc1pd <= '1';
                adc2pd <= '1';
                ft245rw <= '1';
                bufferDataDirection <= '0';
                answerNumber <= "00";
                ft245din <= "01010000";
                if ((ft245wr = '0') and to_boolean(bufferReady)) then
                    state <= DUMP_DATA1;
                    ft245strobe <= '0';
                else
                    ft245strobe <= '1';
                    state <= DUMP_DATA0;
                end if;
            when DUMP_DATA1 =>
                ft245din <= "01010000";
                ft245dataWaitIn <= '0';
                answerNumber <= (answerNumber + 1);
                if (answerNumber = 3) then
                    state <= DUMP_DATA2;
                    bufferOutputInputReady <= '1';
                else
                    state <= DUMP_DATA1;
                end if;
            when DUMP_DATA2 =>
                if to_boolean(ft245dataWaitOut) then
                    state <= DUMP_DATA4;
                    bufferOutputInputReady <= '0';
                    backState <= DUMP_DATA2;
                else
                    bufferOutputInputReady <= '0';
                    ft245din <= bufferDataOut(32-1 downto 24);
                    state <= DUMP_DATA_INT1;
                end if;
            when DUMP_DATA_INT1 =>
                if to_boolean(ft245dataWaitOut) then
                    state <= DUMP_DATA4;
                    backState <= DUMP_DATA_INT1;
                else
                    ft245din <= bufferDataOut(24-1 downto 16);
                    state <= DUMP_DATA_INT2;
                end if;
            when DUMP_DATA_INT2 =>
                if to_boolean(ft245dataWaitOut) then
                    state <= DUMP_DATA4;
                    backState <= DUMP_DATA_INT2;
                else
                    ft245din <= bufferDataOut(16-1 downto 8);
                    state <= DUMP_DATA3;
                end if;
            when DUMP_DATA3 =>
                if to_boolean(bufferReady) then
                    if to_boolean(ft245dataWaitOut) then
                        state <= DUMP_DATA4;
                        bufferOutputInputReady <= '0';
                        backState <= DUMP_DATA3;
                    else
                        ft245din <= bufferDataOut(8-1 downto 0);
                        state <= DUMP_DATA2;
                        bufferOutputInputReady <= '1';
                        oldBufferData <= bufferDataOut;
                    end if;
                else
                    ft245din <= bufferDataOut(8-1 downto 0);
                    ft245dataWaitIn <= '1';
                    state <= IDLE;
                end if;
            when others => -- DUMP_DATA4
                ft245rw <= '1';
                case backState is
                    when DUMP_DATA3 =>
                        ft245din <= oldBufferData(24-1 downto 16);
                    when DUMP_DATA_INT2 =>
                        ft245din <= oldBufferData(32-1 downto 24);
                    when DUMP_DATA_INT1 =>
                        ft245din <= oldBufferData(8-1 downto 0);
                    when others =>
                        ft245din <= oldBufferData(16-1 downto 8);
                end case;
                if (to_boolean(ft245busy) and (not to_boolean(ft245dataWaitOut))) then
                    case backState is
                        when DUMP_DATA3 =>
                            state <= DUMP_DATA3;
                            ft245din <= bufferDataOut(16-1 downto 8);
                        when DUMP_DATA_INT2 =>
                            state <= DUMP_DATA_INT2;
                            ft245din <= bufferDataOut(24-1 downto 16);
                        when DUMP_DATA_INT1 =>
                            state <= DUMP_DATA_INT1;
                            ft245din <= bufferDataOut(32-1 downto 24);
                        when others =>
                            state <= DUMP_DATA2;
                            ft245din <= bufferDataOut(8-1 downto 0);
                    end case;
                    ft245strobe <= '0';
                else
                    ft245strobe <= '1';
                    state <= DUMP_DATA4;
                end if;
        end case;
    end if;
end process CONTROLLER_FSM;

-- This process connects data from ADCs and logic analyzer
-- to single 4byte word connected to input of buffer, 
-- and selects appropriate trigger inputs for triggering
CONTROLLER_TRIGGERING: process (fastClk) is
begin
    if rising_edge(fastClk) then
        bufferDataIn(32-1 downto 24) <= decimator1out;
        bufferDataIn(24-1 downto 16) <= decimator2out;
        bufferDataIn(16-1 downto 0) <= logicAnalyzer;
        case triggerConfiguration is
            when "00000000" =>
                nTrigger <= analog1Trigger;
            when "00000001" =>
                nTrigger <= analog2Trigger;
            when "00000010" =>
                nTrigger <= to_std_logic(to_boolean(analog1Trigger) or to_boolean(digiTrigger));
            when "00000011" =>
                nTrigger <= to_std_logic(to_boolean(analog2Trigger) or to_boolean(digiTrigger));
            when "00000100" =>
                nTrigger <= to_std_logic(to_boolean(analog1Trigger) or to_boolean(analog2Trigger));
            when "00000101" =>
                nTrigger <= to_std_logic(to_boolean(analog1Trigger) or to_boolean(analog2Trigger) or to_boolean(digiTrigger));
            when others =>
                nTrigger <= digiTrigger;
        end case;
    end if;
end process CONTROLLER_TRIGGERING;

-- This process generates trigger approximately after 1second if no trigger happend
CONTROLLER_CONNECTCAPTURE: process (fastClk) is
begin
    if rising_edge(fastClk) then
        if (state = CAPTURE) then
            holdoffCounter <= (holdoffCounter + 1);
            if (to_boolean(nTrigger) or (signed(resize(holdoffCounter, 27)) = (67108864 - 1))) then
                bufferAllowWriteOverlap <= '0';
            else
                bufferAllowWriteOverlap <= bufferAllowWriteOverlap;
            end if;
        else
            holdoffCounter <= "00000000000000000000000000";
            bufferAllowWriteOverlap <= '1';
        end if;
    end if;
end process CONTROLLER_CONNECTCAPTURE;

-- This process creates flag for new value set into decimator
CONTROLLER_NEWFLAG: process (state) is
begin
    if (state = SET_DECIMATION) then
        decimatorNewValueFlag <= '1';
    else
        decimatorNewValueFlag <= '0';
    end if;
end process CONTROLLER_NEWFLAG;

end architecture MyHDL;
