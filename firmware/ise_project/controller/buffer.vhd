-- File: buffer.vhd
-- Generated by MyHDL 0.7
-- Date: Wed Mar 20 19:42:56 2013



package pck_buffer is

    type t_enum_controllerState_1 is (
    INIT,
    ACTIVE,
    READ_DATA,
    READ,
    WRITE,
    WRITE_DATA,
    SET_MODE_REGISTER,
    PRECHARGE,
    AUTO_REFRESH,
    NOP,
    BURST_TERMINATION
);
    type t_enum_tBufStates_2 is (
    INIT,
    WAIT_FOR_SDRAM,
    WRITE_BRAM,
    PREPARE_WRITE_SDRAM,
    PREPARE_WRITE_SDRAM2,
    PREPARE_NEXT_READ,
    PREPARE_READ_SDRAM,
    WRITE_SDRAM,
    READ_BRAM,
    READ_SDRAM,
    FULL_EMPTY_SDRAM,
    FULL_EMPTY_BRAM
);

end package pck_buffer;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_07.all;

use work.pck_buffer.all;

entity buffer is
    port (
        clk: in std_logic;
        reset: in std_logic;
        dataIn: in unsigned(15 downto 0);
        dataOut: out unsigned(15 downto 0);
        bufferReady: out std_logic;
        outputInputReady: in std_logic;
        allowWriteOverlap: in std_logic;
        useSdram: in std_logic;
        dataDirection: in std_logic
    );
end entity buffer;
-- clk - input - clock
-- reset - asynchronous reset
-- dataIn - input - data to be written to SDRAM
-- dataOut - output - data read from SDRAM
-- bufferReady - output - indicates that buffer is ready to input data or output data
-- outputInputReady - input - output/input is ready
-- allowWriteOverlap - input - allow memory to overlap, useful when in trigger armed mode of scope
--                        memory will overwrite previous data when full instead lowering bufferReady
-- useSdram - input - enables or disables usage of sdram for buffering, increases buffer performace but dramatically reduces
--                    capacity of buffer, must be set while reset and hold
-- dataDirection - input - indicates wether to input or output data

architecture MyHDL of buffer is

signal en: std_logic;
signal bufferReady_int: std_logic;
signal bram_address_bottom: unsigned(14 downto 0);
signal overlapped: std_logic;
signal rw: std_logic;
signal burstTerminated: std_logic;
signal nCs: std_logic;
signal ram_dataIn: unsigned(15 downto 0);
signal state: t_enum_tBufStates_2;
signal ram_reset: std_logic;
signal burstModeChanged: std_logic;
signal ram_dataIn_delayed: unsigned(15 downto 0);
signal ba: unsigned(1 downto 0);
signal currentSdramOverlapBoundary: unsigned(21 downto 0);
signal nRas: std_logic;
signal a: unsigned(11 downto 0);
signal address: unsigned(21 downto 0);
signal nCas: std_logic;
signal currentBramOverlapBoundary: unsigned(14 downto 0);
signal dq: unsigned(1 downto 0);
signal cke: std_logic;
signal ramData: unsigned(15 downto 0);
signal ack: std_logic;
signal bram_address_top: unsigned(14 downto 0);
signal nWe: std_logic;
signal ram_address_top: unsigned(21 downto 0);
signal fpBurstMode: std_logic;
signal alreadyRead: std_logic;
signal waitForBurst: std_logic;
signal sdram_controller_burstSize: unsigned(2 downto 0);
signal sdram_controller_refreshTimer: unsigned(22 downto 0);
signal sdram_controller_startupPending: std_logic;
signal sdram_controller_nCas: std_logic;
signal sdram_controller_executeNop: std_logic;
signal sdram_controller_startupTimer: unsigned(13 downto 0);
signal sdram_controller_nCs: std_logic;
signal sdram_controller_refreshDoneFlag: std_logic;
signal sdram_controller_ram_data_drv: unsigned(15 downto 0);
signal sdram_controller_cke: std_logic;
signal sdram_controller_ba: unsigned(1 downto 0);
signal sdram_controller_waitingOp: std_logic;
signal sdram_controller_nRas: std_logic;
signal sdram_controller_waitCounter: unsigned(7 downto 0);
signal sdram_controller_a: unsigned(11 downto 0);
signal sdram_controller_RW_int: std_logic;
signal sdram_controller_row_address: unsigned(11 downto 0);
signal sdram_controller_dq: unsigned(1 downto 0);
signal sdram_controller_cntrlState: t_enum_controllerState_1;
signal sdram_controller_refreshReq: std_logic;
signal sdram_controller_arefEnable: std_logic;
signal sdram_controller_col_address: unsigned(7 downto 0);
signal sdram_controller_dtack: std_logic;
signal sdram_controller_twiceAutorefresh: std_logic;
signal sdram_controller_nWe: std_logic;
signal sdram_controller_CASCounter: unsigned(3 downto 0);
type t_array_fpga_mem is array(0 to 22528-1) of unsigned(15 downto 0);
signal fpga_mem: t_array_fpga_mem;

begin


ramData <= sdram_controller_ram_data_drv;
ramData <= ram_ramData;


BUFFER_SDRAM_CONTROLLER_REFRESHPROCESS: process (clk, ram_reset) is
begin
    if (ram_reset = '1') then
        sdram_controller_refreshTimer <= "00000000000000000000000";
        sdram_controller_refreshReq <= '0';
    elsif falling_edge(clk) then
        if (sdram_controller_refreshTimer < 5333333) then
            sdram_controller_refreshReq <= '0';
            sdram_controller_refreshTimer <= (sdram_controller_refreshTimer + 1);
        elsif to_boolean(sdram_controller_refreshDoneFlag) then
            sdram_controller_refreshReq <= '0';
            sdram_controller_refreshTimer <= "00000000000000000000000";
        else
            sdram_controller_refreshReq <= '1';
        end if;
    end if;
end process BUFFER_SDRAM_CONTROLLER_REFRESHPROCESS;


BUFFER_SDRAM_CONTROLLER_SDRAMCONTROLLER: process (ram_reset, clk) is
begin
    if (ram_reset = '1') then
        sdram_controller_burstSize <= "000";
        sdram_controller_cke <= '0';
        sdram_controller_dq <= "11";
        sdram_controller_nCs <= '1';
        sdram_controller_nRas <= '1';
        sdram_controller_nCas <= '1';
        sdram_controller_nWe <= '1';
        sdram_controller_a <= "000000000000";
        sdram_controller_cntrlState <= INIT;
        sdram_controller_arefEnable <= '1';
        sdram_controller_twiceAutorefresh <= '1';
        sdram_controller_startupTimer <= "00000000000000";
        sdram_controller_dtack <= '1';
        burstTerminated <= '0';
        sdram_controller_refreshDoneFlag <= '0';
        sdram_controller_waitCounter <= "00000000";
        sdram_controller_RW_int <= '0';
        sdram_controller_executeNop <= '0';
        sdram_controller_CASCounter <= "0000";
        sdram_controller_startupPending <= '1';
    elsif falling_edge(clk) then
        case sdram_controller_cntrlState is
            when INIT =>
                sdram_controller_cke <= '1';
                sdram_controller_nCs <= '0';
                sdram_controller_cntrlState <= NOP;
                sdram_controller_dq <= "11";
            when NOP =>
                if (burstModeChanged = '1') then
                    sdram_controller_cntrlState <= SET_MODE_REGISTER;
                    if to_boolean(fpBurstMode) then
                        sdram_controller_burstSize(3-1 downto 0) <= "111";
                    else
                        sdram_controller_burstSize(3-1 downto 0) <= "000";
                    end if;
                    sdram_controller_dtack <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                    sdram_controller_RW_int <= rw;
                    sdram_controller_executeNop <= '0';
                    sdram_controller_dtack <= '1';
                    if to_boolean(sdram_controller_startupPending) then
                        sdram_controller_dq <= "11";
                        if (sdram_controller_startupTimer < 8333) then
                            sdram_controller_startupTimer <= (sdram_controller_startupTimer + 1);
                            sdram_controller_cntrlState <= INIT;
                        else
                            sdram_controller_cntrlState <= PRECHARGE;
                            sdram_controller_a(10) <= '1';
                        end if;
                    elsif (to_boolean(sdram_controller_refreshReq) and to_boolean(sdram_controller_arefEnable)) then
                        sdram_controller_dq <= "00";
                        sdram_controller_refreshDoneFlag <= '1';
                        sdram_controller_cntrlState <= AUTO_REFRESH;
                    elsif to_boolean(sdram_controller_waitingOp) then
                        sdram_controller_dq <= "00";
                        sdram_controller_arefEnable <= '0';
                        sdram_controller_refreshDoneFlag <= '0';
                        sdram_controller_dtack <= '0';
                        sdram_controller_cntrlState <= ACTIVE;
                    end if;
                end if;
            when PRECHARGE =>
                burstTerminated <= '0';
                if to_boolean(sdram_controller_executeNop) then
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '0';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '0';
                    sdram_controller_a(10) <= '1';
                end if;
                if (sdram_controller_waitCounter < 3) then
                    sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                    sdram_controller_executeNop <= '1';
                else
                    sdram_controller_executeNop <= '0';
                    sdram_controller_waitCounter <= "00000000";
                    if to_boolean(sdram_controller_startupPending) then
                        sdram_controller_cntrlState <= AUTO_REFRESH;
                    else
                        sdram_controller_cntrlState <= NOP;
                    end if;
                end if;
            when AUTO_REFRESH =>
                if to_boolean(sdram_controller_executeNop) then
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '0';
                    sdram_controller_nCas <= '0';
                    sdram_controller_nWe <= '1';
                end if;
                if (sdram_controller_waitCounter < 10) then
                    sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                    sdram_controller_executeNop <= '1';
                else
                    sdram_controller_executeNop <= '0';
                    sdram_controller_waitCounter <= "00000000";
                    if to_boolean(sdram_controller_twiceAutorefresh) then
                        sdram_controller_twiceAutorefresh <= '0';
                    else
                        if to_boolean(sdram_controller_startupPending) then
                            sdram_controller_cntrlState <= SET_MODE_REGISTER;
                            if to_boolean(fpBurstMode) then
                                sdram_controller_burstSize(3-1 downto 0) <= "111";
                            else
                                sdram_controller_burstSize(3-1 downto 0) <= "000";
                            end if;
                        else
                            sdram_controller_cntrlState <= NOP;
                        end if;
                    end if;
                end if;
            when SET_MODE_REGISTER =>
                sdram_controller_a(12-1 downto 7) <= "00000";
                sdram_controller_a(7-1 downto 4) <= "011";
                sdram_controller_a(3) <= '0';
                sdram_controller_a(3-1 downto 0) <= sdram_controller_burstSize;
                if to_boolean(sdram_controller_executeNop) then
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '0';
                    sdram_controller_nCas <= '0';
                    sdram_controller_nWe <= '0';
                end if;
                if (sdram_controller_waitCounter < 2) then
                    sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                    sdram_controller_executeNop <= '1';
                else
                    sdram_controller_waitCounter <= "00000000";
                    sdram_controller_startupPending <= '0';
                    sdram_controller_dtack <= '0';
                    sdram_controller_cntrlState <= NOP;
                    sdram_controller_executeNop <= '0';
                end if;
            when ACTIVE =>
                sdram_controller_a <= sdram_controller_row_address;
                if to_boolean(sdram_controller_executeNop) then
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '0';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                end if;
                if (sdram_controller_waitCounter < 3) then
                    sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                    sdram_controller_executeNop <= '1';
                else
                    sdram_controller_executeNop <= '0';
                    sdram_controller_waitCounter <= "00000000";
                    if to_boolean(sdram_controller_RW_int) then
                        sdram_controller_cntrlState <= WRITE;
                        sdram_controller_dtack <= '1';
                    else
                        sdram_controller_cntrlState <= READ;
                        sdram_controller_dtack <= '1';
                    end if;
                end if;
            when READ =>
                sdram_controller_dq <= "00";
                sdram_controller_a(8-1 downto 0) <= sdram_controller_col_address;
                sdram_controller_a(10) <= '0';
                if to_boolean(sdram_controller_executeNop) then
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '0';
                    sdram_controller_nWe <= '1';
                end if;
                if (sdram_controller_CASCounter < 3) then
                    sdram_controller_CASCounter <= (sdram_controller_CASCounter + 1);
                    sdram_controller_executeNop <= '1';
                else
                    if (sdram_controller_burstSize = 0) then
                        burstTerminated <= '1';
                        sdram_controller_cntrlState <= PRECHARGE;
                        sdram_controller_arefEnable <= '1';
                        sdram_controller_executeNop <= '0';
                        sdram_controller_dtack <= '1';
                    else
                        sdram_controller_CASCounter <= "0000";
                        sdram_controller_executeNop <= '0';
                        sdram_controller_dtack <= '1';
                        sdram_controller_cntrlState <= READ_DATA;
                    end if;
                    sdram_controller_waitCounter <= "00000000";
                end if;
            when READ_DATA =>
                sdram_controller_nCs <= '0';
                sdram_controller_nRas <= '1';
                sdram_controller_nCas <= '1';
                sdram_controller_nWe <= '1';
                sdram_controller_a(8-1 downto 0) <= sdram_controller_col_address;
                if (sdram_controller_waitCounter = 254) then
                    sdram_controller_cntrlState <= BURST_TERMINATION;
                    burstTerminated <= '1';
                    sdram_controller_arefEnable <= '1';
                    sdram_controller_waitCounter <= "00000000";
                else
                    sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                end if;
            when WRITE =>
                sdram_controller_dq <= "00";
                sdram_controller_a(11) <= '0';
                sdram_controller_a(10-1 downto 9) <= "0";
                sdram_controller_a(8-1 downto 0) <= sdram_controller_col_address;
                sdram_controller_dtack <= '1';
                if to_boolean(sdram_controller_executeNop) then
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '1';
                    sdram_controller_nWe <= '1';
                else
                    sdram_controller_nCs <= '0';
                    sdram_controller_nRas <= '1';
                    sdram_controller_nCas <= '0';
                    sdram_controller_nWe <= '0';
                end if;
                if (sdram_controller_burstSize = 0) then
                    if (sdram_controller_waitCounter < 2) then
                        sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                        sdram_controller_executeNop <= '1';
                        burstTerminated <= '1';
                    else
                        sdram_controller_executeNop <= '0';
                        sdram_controller_waitCounter <= "00000000";
                        sdram_controller_arefEnable <= '1';
                        sdram_controller_cntrlState <= PRECHARGE;
                        sdram_controller_waitCounter <= "00000000";
                    end if;
                else
                    sdram_controller_executeNop <= '0';
                    sdram_controller_dtack <= '1';
                    sdram_controller_cntrlState <= WRITE_DATA;
                    sdram_controller_waitCounter <= "00000000";
                end if;
            when WRITE_DATA =>
                sdram_controller_nCs <= '0';
                sdram_controller_nRas <= '1';
                sdram_controller_nCas <= '1';
                sdram_controller_nWe <= '1';
                sdram_controller_a(11) <= '0';
                sdram_controller_a(10-1 downto 9) <= "0";
                sdram_controller_a(8-1 downto 0) <= sdram_controller_col_address;
                if (sdram_controller_waitCounter = 254) then
                    sdram_controller_cntrlState <= BURST_TERMINATION;
                    burstTerminated <= '1';
                    sdram_controller_arefEnable <= '1';
                    sdram_controller_waitCounter <= "00000000";
                else
                    sdram_controller_waitCounter <= (sdram_controller_waitCounter + 1);
                end if;
            when BURST_TERMINATION =>
                sdram_controller_nCs <= '0';
                sdram_controller_nRas <= '1';
                sdram_controller_nCas <= '1';
                sdram_controller_nWe <= '0';
                sdram_controller_cntrlState <= PRECHARGE;
            when others =>
                sdram_controller_dtack <= '1';
                sdram_controller_cntrlState <= NOP;
                sdram_controller_nCs <= '1';
                sdram_controller_nRas <= '1';
                sdram_controller_nCas <= '1';
                sdram_controller_nWe <= '1';
                sdram_controller_cke <= '1';
                sdram_controller_dq <= "11";
                sdram_controller_a <= "000000000000";
                burstTerminated <= '0';
        end case;
    end if;
end process BUFFER_SDRAM_CONTROLLER_SDRAMCONTROLLER;


BUFFER_SDRAM_CONTROLLER_ADDRESSTRANSLATE: process (clk, ram_reset) is
begin
    if (ram_reset = '1') then
        sdram_controller_row_address <= "000000000000";
        sdram_controller_col_address <= "00000000";
        sdram_controller_ba <= "00";
        sdram_controller_waitingOp <= '0';
        sdram_controller_ram_data_drv <= (others => 'Z');
    elsif falling_edge(clk) then
        if to_boolean(rw) then
            sdram_controller_ram_data_drv <= ram_dataIn_delayed;
        else
            sdram_controller_ram_data_drv <= (others => 'Z');
        end if;
        if to_boolean(en) then
            sdram_controller_waitingOp <= '1';
            sdram_controller_ba <= address(22-1 downto 20);
            sdram_controller_row_address <= address(20-1 downto 8);
            sdram_controller_col_address <= address(8-1 downto 0);
        elsif (sdram_controller_cntrlState = ACTIVE) then
            sdram_controller_waitingOp <= '0';
        end if;
    end if;
end process BUFFER_SDRAM_CONTROLLER_ADDRESSTRANSLATE;



ba <= sdram_controller_ba;
a <= sdram_controller_a;
dq <= sdram_controller_dq;
cke <= sdram_controller_cke;
nCs <= sdram_controller_nCs;
nRas <= sdram_controller_nRas;
nCas <= sdram_controller_nCas;
nWe <= sdram_controller_nWe;
ack <= sdram_controller_dtack;


BUFFER_FSM: process (clk, reset) is
begin
    if (reset = '1') then
        state <= INIT;
        overlapped <= '0';
        ram_dataIn <= "0000000000000000";
        address <= "0000000000000000000000";
        ram_reset <= '1';
        rw <= '0';
        en <= '0';
        fpBurstMode <= '0';
        burstModeChanged <= '0';
        bram_address_top <= "000000000000000";
        bram_address_bottom <= "000000000000000";
        bufferReady_int <= '0';
        waitForBurst <= '0';
        alreadyRead <= '0';
        dataOut <= "0000000000000000";
        ram_address_top <= "0000000000000000000000";
    elsif rising_edge(clk) then
        if (state = INIT) then
            overlapped <= '0';
            if to_boolean(useSdram) then
                state <= WAIT_FOR_SDRAM;
                ram_dataIn <= "0000000000000000";
                address <= "0000000000000000000000";
                ram_reset <= '0';
                rw <= '0';
                en <= '1';
                fpBurstMode <= '1';
                burstModeChanged <= '0';
            else
                if to_boolean(outputInputReady) then
                    if to_boolean(dataDirection) then
                        state <= WRITE_BRAM;
                        bufferReady_int <= '1';
                    else
                        state <= READ_BRAM;
                        bufferReady_int <= '1';
                    end if;
                else
                    state <= INIT;
                end if;
            end if;
        end if;
        if (state = WAIT_FOR_SDRAM) then
            if ((((ack = '0') and (not to_boolean(waitForBurst))) or ((burstTerminated = '0') and to_boolean(waitForBurst))) and to_boolean(outputInputReady)) then
                bufferReady_int <= '1';
                if to_boolean(dataDirection) then
                    state <= PREPARE_WRITE_SDRAM;
                else
                    state <= PREPARE_READ_SDRAM;
                    fpBurstMode <= '0';
                    burstModeChanged <= '1';
                end if;
                address <= "0000000000000000000000";
                en <= '1';
                rw <= '1';
            else
                state <= WAIT_FOR_SDRAM;
            end if;
        end if;
        if (state = PREPARE_WRITE_SDRAM) then
            if (ack = '0') then
                state <= PREPARE_WRITE_SDRAM2;
                en <= '0';
            else
                if (((bram_address_top + 1) mod 22528) = bram_address_bottom) then
                    state <= PREPARE_WRITE_SDRAM2;
                else
                    bram_address_top <= ((bram_address_top + 1) mod 22528);
                    state <= PREPARE_WRITE_SDRAM;
                    fpga_mem(to_integer(bram_address_top)) <= dataIn;
                end if;
            end if;
        end if;
        if (state = PREPARE_WRITE_SDRAM2) then
            if (ack = '1') then
                state <= WRITE_SDRAM;
                if (bram_address_bottom /= bram_address_top) then
                    ram_dataIn <= fpga_mem(to_integer(bram_address_bottom));
                    bram_address_bottom <= ((bram_address_bottom + 1) mod 22528);
                else
                    ram_dataIn <= dataIn;
                end if;
            else
                if (((bram_address_top + 1) mod 22528) = bram_address_bottom) then
                    bufferReady_int <= '0';
                    state <= WRITE_SDRAM;
                else
                    state <= PREPARE_WRITE_SDRAM2;
                    fpga_mem(to_integer(bram_address_top)) <= dataIn;
                    bram_address_top <= ((bram_address_top + 1) mod 22528);
                end if;
            end if;
        end if;
        if (state = WRITE_SDRAM) then
            if to_boolean(burstTerminated) then
                address <= ((address + 256) mod 22528);
                en <= '1';
                if ((address <= currentSdramOverlapBoundary) and ((address + 256) >= currentSdramOverlapBoundary)) then
                    overlapped <= '1';
                    if to_boolean(allowWriteOverlap) then
                        state <= PREPARE_WRITE_SDRAM;
                    else
                        state <= FULL_EMPTY_SDRAM;
                        address <= (address - 1);
                    end if;
                else
                    if to_boolean(bufferReady_int) then
                        state <= PREPARE_WRITE_SDRAM;
                    else
                        state <= FULL_EMPTY_SDRAM;
                    end if;
                end if;
            else
                if (bram_address_bottom /= bram_address_top) then
                    bram_address_bottom <= ((bram_address_bottom + 1) mod 22528);
                    ram_dataIn <= fpga_mem(to_integer(bram_address_bottom));
                else
                    if to_boolean(bufferReady_int) then
                        ram_dataIn <= dataIn;
                    else
                        ram_dataIn <= "0000000000000000";
                    end if;
                end if;
            end if;
        end if;
        if (state = FULL_EMPTY_SDRAM) then
            bufferReady_int <= '0';
            if to_boolean(dataDirection) then
                state <= FULL_EMPTY_SDRAM;
                ram_address_top <= address;
            else
                if to_boolean(alreadyRead) then
                    state <= FULL_EMPTY_SDRAM;
                else
                    alreadyRead <= '1';
                    state <= WAIT_FOR_SDRAM;
                    waitForBurst <= '1';
                    bram_address_top <= "000000000000000";
                    bram_address_bottom <= "000000000000000";
                end if;
            end if;
        end if;
        if (state = PREPARE_READ_SDRAM) then
            if (ack = '0') then
                burstModeChanged <= '0';
                rw <= '0';
                address <= (address + 1);
                en <= '1';
                state <= READ_SDRAM;
            else
                state <= PREPARE_READ_SDRAM;
            end if;
            if (to_boolean(outputInputReady) and (bram_address_bottom < bram_address_top)) then
                dataOut <= fpga_mem(to_integer(bram_address_bottom));
                bram_address_bottom <= (bram_address_bottom + 1);
            end if;
        end if;
        if (state = READ_SDRAM) then
            if (ack = '0') then
                if ((bram_address_top + 1) /= bram_address_bottom) then
                    en <= '0';
                    state <= PREPARE_NEXT_READ;
                else
                    state <= READ_SDRAM;
                end if;
            else
                state <= READ_SDRAM;
            end if;
            if (to_boolean(outputInputReady) and (bram_address_bottom < bram_address_top)) then
                dataOut <= fpga_mem(to_integer(bram_address_bottom));
                bram_address_bottom <= (bram_address_bottom + 1);
            end if;
        end if;
        if (state = PREPARE_NEXT_READ) then
            if (ack = '1') then
                bram_address_top <= ((bram_address_top + 1) mod 22528);
                fpga_mem(to_integer(bram_address_top)) <= ramData;
            end if;
            if to_boolean(burstTerminated) then
                address <= (address + 1);
                if (address < ram_address_top) then
                    en <= '1';
                    state <= READ_SDRAM;
                else
                    state <= FULL_EMPTY_SDRAM;
                end if;
            else
                state <= PREPARE_NEXT_READ;
            end if;
            if (to_boolean(outputInputReady) and (bram_address_bottom < bram_address_top)) then
                dataOut <= fpga_mem(to_integer(bram_address_bottom));
                bram_address_bottom <= (bram_address_bottom + 1);
            end if;
        end if;
        if (state = WRITE_BRAM) then
            if (bram_address_top = currentBramOverlapBoundary) then
                overlapped <= '1';
                if to_boolean(allowWriteOverlap) then
                    fpga_mem(to_integer(bram_address_top)) <= dataIn;
                    state <= WRITE_BRAM;
                    bram_address_top <= ((bram_address_top + 1) mod 22528);
                else
                    fpga_mem(to_integer(bram_address_top)) <= dataIn;
                    state <= FULL_EMPTY_BRAM;
                end if;
            else
                fpga_mem(to_integer(bram_address_top)) <= dataIn;
                state <= WRITE_BRAM;
                bram_address_top <= ((bram_address_top + 1) mod 22528);
            end if;
        end if;
        if (state = FULL_EMPTY_BRAM) then
            bufferReady_int <= '0';
            if to_boolean(dataDirection) then
                state <= FULL_EMPTY_BRAM;
            else
                if to_boolean(alreadyRead) then
                    state <= FULL_EMPTY_BRAM;
                else
                    if to_boolean(outputInputReady) then
                        state <= READ_BRAM;
                        bram_address_bottom <= ((bram_address_top + 1) mod 22528);
                    else
                        state <= FULL_EMPTY_BRAM;
                    end if;
                end if;
            end if;
        end if;
        if (state = READ_BRAM) then
            bufferReady_int <= '1';
            if to_boolean(outputInputReady) then
                if (bram_address_bottom = bram_address_top) then
                    dataOut <= fpga_mem(to_integer(bram_address_bottom));
                    state <= FULL_EMPTY_BRAM;
                else
                    dataOut <= fpga_mem(to_integer(bram_address_bottom));
                    bram_address_bottom <= ((bram_address_bottom + 1) mod 22528);
                    state <= READ_BRAM;
                end if;
            else
                state <= READ_BRAM;
            end if;
        end if;
    end if;
end process BUFFER_FSM;


BUFFER_DELAY: process (clk) is
begin
    if falling_edge(clk) then
        ram_dataIn_delayed <= ram_dataIn;
    end if;
end process BUFFER_DELAY;


BUFFER_SETBOUNDARY: process (allowWriteOverlap, reset) is
begin
    if (reset = '1') then
        currentSdramOverlapBoundary <= to_unsigned(22528 - 1, 22);
        currentBramOverlapBoundary <= to_unsigned(22528 - 1, 15);
    elsif falling_edge(allowWriteOverlap) then
        if (allowWriteOverlap = '0') then
            if (address > 3000) then
                currentSdramOverlapBoundary <= (address - 3000);
            else
                if to_boolean(overlapped) then
                    currentSdramOverlapBoundary <= ((address + 22528) - 3000);
                else
                    currentSdramOverlapBoundary <= to_unsigned(22528 - 1, 22);
                end if;
            end if;
            if (bram_address_top > 3000) then
                currentBramOverlapBoundary <= (bram_address_top - 3000);
            else
                if to_boolean(overlapped) then
                    currentBramOverlapBoundary <= ((bram_address_top + 22528) - 3000);
                else
                    currentBramOverlapBoundary <= to_unsigned(22528 - 1, 15);
                end if;
            end if;
        end if;
    end if;
end process BUFFER_SETBOUNDARY;



bufferReady <= bufferReady_int;

end architecture MyHDL;
