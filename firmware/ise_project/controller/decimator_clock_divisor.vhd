-- File: decimator_clock_divisor.vhd
-- Generated by MyHDL 0.7
-- Date: Thu May  9 20:55:44 2013


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_07.all;

entity decimator_clock_divisor is
    port (
        clk: in std_logic;
        reset: in std_logic;
        decimationRatioBase: in unsigned(3 downto 0);
        decimationRatio: inout unsigned(8 downto 0);
        clkDataOut: out std_logic;
        newValueFlag: in std_logic;
        alwaysEn: out std_logic
    );
end entity decimator_clock_divisor;
-- clk - input - clock
-- reset - asynchronous reset
-- decimationRatioBase - base of oversamplig ratio i.e. 2^0, 2^1, 2^2 etc..

architecture MyHDL of decimator_clock_divisor is

signal clkDataOut_int: std_logic;
signal counter: unsigned(6 downto 0);
signal flagRegistered: std_logic;
signal metaCounter: unsigned(3 downto 0);

begin



-- Divides ADC clock according to selected decimation ratio
DECIMATOR_CLOCK_DIVISOR_CLOCKDIVISOR: process (clk, reset) is
begin
    if (reset = '1') then
        counter <= "0000000";
        clkDataOut_int <= '0';
    elsif rising_edge(clk) then
        if (decimationRatio = 1) then
            counter <= "0000000";
            clkDataOut_int <= '1';
        else
            if (counter = (shift_right(decimationRatio, 1) - 1)) then
                counter <= "0000000";
                clkDataOut_int <= to_std_logic((not to_boolean(clkDataOut_int)));
            else
                counter <= (counter + 1);
            end if;
        end if;
    end if;
end process DECIMATOR_CLOCK_DIVISOR_CLOCKDIVISOR;

-- Output clock is enabled only when decimation ratio is higher than 1:1
DECIMATOR_CLOCK_DIVISOR_ENABLEOUTCLK: process (clkDataOut_int, decimationRatio) is
begin
    if (decimationRatio = 1) then
        clkDataOut <= '1';
        alwaysEn <= '1';
    else
        alwaysEn <= '0';
        clkDataOut <= clkDataOut_int;
    end if;
end process DECIMATOR_CLOCK_DIVISOR_ENABLEOUTCLK;

-- This process registers flag indicating new data from
-- lower clock domain and then waits 8 clock cycles to prevent
-- data coccuprion caused by metastability of lower frequency registers,
-- then it updates decimationRatio out of exponent value stored in decimationRatioBase
-- where decimationRatio = 2^deimationRatioBase
DECIMATOR_CLOCK_DIVISOR_DECIMATIONRATIOCONV: process (clk, reset) is
begin
    if (reset = '1') then
        metaCounter <= "0000";
        flagRegistered <= '0';
        decimationRatio <= "000000001";
    elsif rising_edge(clk) then
        if to_boolean(newValueFlag) then
            metaCounter <= "0000";
            flagRegistered <= '1';
        else
            if to_boolean(flagRegistered) then
                if (metaCounter = 8) then
                    case decimationRatioBase is
                        when "0000" =>
                            decimationRatio <= "000000001";
                        when "0001" =>
                            decimationRatio <= "000000010";
                        when "0010" =>
                            decimationRatio <= "000000100";
                        when "0011" =>
                            decimationRatio <= "000001000";
                        when "0100" =>
                            decimationRatio <= "000010000";
                        when "0101" =>
                            decimationRatio <= "000100000";
                        when "0110" =>
                            decimationRatio <= "001000000";
                        when "0111" =>
                            decimationRatio <= "010000000";
                        when others =>
                            decimationRatio <= "100000000";
                    end case;
                    metaCounter <= "0000";
                    flagRegistered <= '0';
                else
                    metaCounter <= (metaCounter + 1);
                end if;
            else
                decimationRatio <= decimationRatio;
            end if;
        end if;
    end if;
end process DECIMATOR_CLOCK_DIVISOR_DECIMATIONRATIOCONV;

end architecture MyHDL;
