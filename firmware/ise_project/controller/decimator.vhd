-- File: decimator.vhd
-- Generated by MyHDL 0.7
-- Date: Thu May  9 18:08:46 2013


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_07.all;

entity decimator is
    port (
        clk: in std_logic;
        reset: in std_logic;
        dataIn: in unsigned(7 downto 0);
        dataOut: out unsigned(7 downto 0);
        decimationRatio: in unsigned(8 downto 0);
        decimationRatioBase: in unsigned(3 downto 0);
        decimationStyle_ext: in unsigned(1 downto 0);
        dataClk: in std_logic;
        newValueFlag: in std_logic
    );
end entity decimator;
-- clk - input - clock
-- reset - asynchronous reset
-- dataIn - input - data to be decimated
-- dataOut - output - decimated data
-- decimationStyle - way of decimation: 00 - simple, 01 - dithering, 10 - miniMax, 11 - average
-- decimationRatio - ratio of decimation
-- decimationRatioBase - exponent with base of 2 (eg 2^decimationRatioBase = decimationRatio)
-- dataClk - decimated data clock
-- newValueFlag - flag of new value in decimationStyle register

architecture MyHDL of decimator is

signal lfsr: unsigned(9 downto 0);
signal maxValue: unsigned(7 downto 0);
signal minValue: unsigned(7 downto 0);
signal flagRegistered: std_logic;
signal bufferCounter: unsigned(7 downto 0);
signal decimationSum: unsigned(15 downto 0);
signal dataClkEdge: std_logic;
signal maxPeriod: std_logic;
signal metaCounter: unsigned(3 downto 0);
signal decimationStyle: unsigned(1 downto 0);
signal dataOut_decimated: unsigned(7 downto 0);
type t_array_buff is array(0 to 256-1) of unsigned(7 downto 0);
signal buff: t_array_buff;

begin



-- This process fills in buffer for dithering mode of decimation
DECIMATOR_FILLBUFFER: process (clk) is
begin
    if rising_edge(clk) then
        buff(to_integer(bufferCounter)) <= dataIn;
    end if;
end process DECIMATOR_FILLBUFFER;

-- This process makes pseudorandom numbers utilizing LFSR 
-- (http://en.wikipedia.org/wiki/Linear_feedback_shift_register)
DECIMATOR_LFSR_PROC: process (reset, clk) is
begin
    if (reset = '1') then
        lfsr <= "0111010100";
    elsif rising_edge(clk) then
        if to_boolean(dataClk) then
            lfsr <= unsigned'(lfsr((10 - 1)-1 downto 0) & (lfsr(9) xor lfsr(6)));
        end if;
    end if;
end process DECIMATOR_LFSR_PROC;

-- This is main process of decimator which on rising edge od data clock
-- outputs decimated data according to selected decimation style
-- for simple decimation it just pases current input date from adc,
-- for dithering it takes random sample from decimated interval,
-- for peak detection it takes maximum or minimum sample,
-- for smoothing it makes mean out of decimated interval by shifting data right
DECIMATOR_OUTPUT: process (clk, reset) is
begin
    if (reset = '1') then
        dataOut_decimated <= "00000000";
        maxPeriod <= '0';
        maxValue <= "00000000";
        minValue <= "11111111";
        decimationSum <= "0000000000000000";
        dataClkEdge <= '1';
    elsif rising_edge(clk) then
        if ((dataClk = '1') and (dataClkEdge = '1')) then
            dataClkEdge <= '0';
            decimationSum(16-1 downto 8) <= "00000000";
            decimationSum(8-1 downto 0) <= dataIn;
            maxValue <= "00000000";
            minValue <= "11111111";
            if (decimationRatio > 0) then
                case decimationStyle is
                    when "00" =>
                        dataOut_decimated <= dataIn;
                    when "01" =>
                        if (decimationRatio = 2) then
                            dataOut_decimated <= buff(to_integer(lfsr(1-1 downto 0)));
                        elsif (decimationRatio = 4) then
                            dataOut_decimated <= buff(to_integer(lfsr(2-1 downto 0)));
                        elsif (decimationRatio = 8) then
                            dataOut_decimated <= buff(to_integer(lfsr(3-1 downto 0)));
                        elsif (decimationRatio = 16) then
                            dataOut_decimated <= buff(to_integer(lfsr(4-1 downto 0)));
                        elsif (decimationRatio = 32) then
                            dataOut_decimated <= buff(to_integer(lfsr(5-1 downto 0)));
                        elsif (decimationRatio = 64) then
                            dataOut_decimated <= buff(to_integer(lfsr(6-1 downto 0)));
                        elsif (decimationRatio = 128) then
                            dataOut_decimated <= buff(to_integer(lfsr(7-1 downto 0)));
                        elsif (decimationRatio = 256) then
                            dataOut_decimated <= buff(to_integer(lfsr(8-1 downto 0)));
                        end if;
                    when "10" =>
                        maxPeriod <= to_std_logic((not to_boolean(maxPeriod)));
                        if to_boolean(maxPeriod) then
                            dataOut_decimated <= maxValue;
                        else
                            dataOut_decimated <= minValue;
                        end if;
                    when others => -- "11"
                        if (decimationRatioBase = 1) then
                            dataOut_decimated <= decimationSum(9-1 downto 1);
                        elsif (decimationRatioBase = 2) then
                            dataOut_decimated <= decimationSum(10-1 downto 2);
                        elsif (decimationRatioBase = 3) then
                            dataOut_decimated <= decimationSum(11-1 downto 3);
                        elsif (decimationRatioBase = 4) then
                            dataOut_decimated <= decimationSum(12-1 downto 4);
                        elsif (decimationRatioBase = 5) then
                            dataOut_decimated <= decimationSum(13-1 downto 5);
                        elsif (decimationRatioBase = 6) then
                            dataOut_decimated <= decimationSum(14-1 downto 6);
                        elsif (decimationRatioBase = 7) then
                            dataOut_decimated <= decimationSum(15-1 downto 7);
                        elsif (decimationRatioBase = 8) then
                            dataOut_decimated <= decimationSum(16-1 downto 8);
                        end if;
                end case;
            end if;
        else
            if (dataClk = '0') then
                dataClkEdge <= '1';
            end if;
            decimationSum <= (decimationSum + ("00000000" & dataIn));
            if (dataIn > maxValue) then
                maxValue <= dataIn;
            end if;
            if (dataIn < minValue) then
                minValue <= dataIn;
            end if;
        end if;
    end if;
end process DECIMATOR_OUTPUT;

-- This process counts up from 0 to decimationRatio creating pointer
-- into buffer memory for saving samples in dithering mode of decimator
DECIMATOR_BUFFERCNT: process (clk, reset) is
begin
    if (reset = '1') then
        bufferCounter <= "00000000";
    elsif rising_edge(clk) then
        if (decimationRatio > 0) then
            if (bufferCounter = (decimationRatio - 1)) then
                bufferCounter <= "00000000";
            else
                bufferCounter <= (bufferCounter + 1);
            end if;
        end if;
    end if;
end process DECIMATOR_BUFFERCNT;

-- This process connects appropriate output 
-- according to selected decimation ratio
DECIMATOR_OUTPUTCONNECT: process (clk, reset) is
begin
    if (reset = '1') then
        dataOut <= "00000000";
    elsif rising_edge(clk) then
        if (decimationRatio = 1) then
            dataOut <= dataIn;
        else
            dataOut <= dataOut_decimated;
        end if;
    end if;
end process DECIMATOR_OUTPUTCONNECT;

-- This process registers flag indicating new data from
-- lower clock domain and then waits 8 clock cycles to prevent
-- data coccuprion caused by metastability of lower frequency registers
DECIMATOR_NEWDATA: process (clk, reset) is
begin
    if (reset = '1') then
        metaCounter <= "0000";
        flagRegistered <= '0';
        decimationStyle <= "00";
    elsif rising_edge(clk) then
        if to_boolean(newValueFlag) then
            metaCounter <= "0000";
            flagRegistered <= '1';
        else
            if to_boolean(flagRegistered) then
                if (metaCounter = 8) then
                    decimationStyle <= decimationStyle_ext;
                    metaCounter <= "0000";
                    flagRegistered <= '0';
                else
                    metaCounter <= (metaCounter + 1);
                end if;
            else
                decimationStyle <= decimationStyle;
            end if;
        end if;
    end if;
end process DECIMATOR_NEWDATA;

end architecture MyHDL;
