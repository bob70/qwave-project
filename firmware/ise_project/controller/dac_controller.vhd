-- File: dac_controller.vhd
-- Generated by MyHDL 0.7
-- Date: Thu May  9 18:39:47 2013



package pck_dac_controller is

    type t_enum_tDacStates_1 is (
    IDLE,
    WRITE_PREPARE,
    WRITE0,
    WRITE1
);

end package pck_dac_controller;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_07.all;

use work.pck_dac_controller.all;

entity dac_controller is
    port (
        clk: in std_logic;
        reset: in std_logic;
        vrefTopA: in unsigned(7 downto 0);
        vrefTopB: in unsigned(7 downto 0);
        vrefBotA: in unsigned(7 downto 0);
        vrefBotB: in unsigned(7 downto 0);
        strobe: in std_logic;
        serialOut: out std_logic;
        load: out std_logic;
        ldac: out std_logic;
        clkDacOut: out std_logic;
        busy: out std_logic
    );
end entity dac_controller;
-- ckl - clock input
-- vrefTopA - parellel vrefTopA value
-- vrefTopB - parellel vrefTopB value
-- vrefBotA - parellel vrefBotA value
-- vrefBotA - parellel vrefBotB value
-- strobe - strobe parellel values
-- serialOut - respective serialized output do dac
-- load - load output for DAC
-- ldac - ldac output for DAC
-- clkDacOut - clk for DAC
-- busy - output if controller is busy

architecture MyHDL of dac_controller is

signal vrefTopAint: unsigned(7 downto 0);
signal vrefBotAint: unsigned(7 downto 0);
signal vrefBotBint: unsigned(7 downto 0);
signal halfMhzClock: std_logic;
signal state: t_enum_tDacStates_1;
signal shiftCounter: unsigned(3 downto 0);
signal clkEn: std_logic;
signal address: unsigned(1 downto 0);
signal counter: unsigned(5 downto 0);
signal outputWord: unsigned(10 downto 0);
signal vrefTopBint: unsigned(7 downto 0);

begin



-- This process divides input 60MHz clock to internal 
-- 500Khz clock used to comuniate with DAC
DAC_CONTROLLER_CLOCKDIVISOR: process (clk, reset) is
begin
    if (reset = '1') then
        counter <= "000000";
        halfMhzClock <= '0';
    elsif rising_edge(clk) then
        if (signed(resize(counter, 7)) = ((120 / 2) - 1)) then
            counter <= "000000";
            halfMhzClock <= to_std_logic((not to_boolean(halfMhzClock)));
        else
            counter <= (counter + 1);
        end if;
    end if;
end process DAC_CONTROLLER_CLOCKDIVISOR;

-- This process connects internal clock to DAC only when sending commads
DAC_CONTROLLER_CONNECTCLOCK: process (clkEn, halfMhzClock) is
begin
    if to_boolean(clkEn) then
        clkDacOut <= halfMhzClock;
    else
        clkDacOut <= '0';
    end if;
end process DAC_CONTROLLER_CONNECTCLOCK;

-- This process is control FSM of DAC controller,
-- in IDLE states it senses STROBE signal going HIGH and
-- checks reference voltage values if bottom reference voltage is not set
-- higher than top reference votage and then transitions to state WRITE_PREPARE
-- in which sets output word transmitted to DAC according to current address,
-- after all four words were trasmitted, controller sets DAC to update all outputs
DAC_CONTROLLER_FSM: process (halfMhzClock, reset) is
begin
    if (reset = '1') then
        vrefTopAint <= "01100100";
        vrefBotAint <= "00000000";
        vrefTopBint <= "01100100";
        vrefBotBint <= "00000000";
        load <= '1';
        ldac <= '1';
        busy <= '1';
        address <= "00";
        state <= IDLE;
        serialOut <= '0';
        shiftCounter <= "0000";
        clkEn <= '0';
        outputWord <= "00000000000";
    elsif rising_edge(halfMhzClock) then
        case state is
            when IDLE =>
                load <= '1';
                ldac <= '1';
                if (strobe = '1') then
                    state <= WRITE_PREPARE;
                    busy <= '1';
                    address <= "00";
                    shiftCounter <= "0000";
                    if (vrefTopA >= vrefBotA) then
                        vrefTopAint <= vrefTopA;
                        vrefBotAint <= vrefBotA;
                    end if;
                    if (vrefTopB >= vrefBotB) then
                        vrefTopBint <= vrefTopB;
                        vrefBotBint <= vrefBotB;
                    end if;
                else
                    state <= IDLE;
                    busy <= '0';
                end if;
            when WRITE_PREPARE =>
                load <= '1';
                ldac <= '1';
                outputWord(11-1 downto 9) <= address;
                outputWord(8) <= '1';
                case address is
                    when "00" =>
                        outputWord(8-1 downto 0) <= vrefBotBint;
                    when "01" =>
                        outputWord(8-1 downto 0) <= vrefTopBint;
                    when "10" =>
                        outputWord(8-1 downto 0) <= vrefTopAint;
                    when others =>
                        outputWord(8-1 downto 0) <= vrefBotAint;
                end case;
                state <= WRITE0;
            when WRITE0 =>
                if (shiftCounter < 11) then
                    clkEn <= '1';
                    serialOut <= outputWord(10);
                    outputWord <= (shift_left(outputWord, 1) mod 2048);
                    shiftCounter <= (shiftCounter + 1);
                    state <= WRITE0;
                else
                    shiftCounter <= "0000";
                    state <= WRITE1;
                    clkEn <= '0';
                    load <= '0';
                    load <= '0';
                end if;
            when others => -- WRITE1
                if (address = 3) then
                    ldac <= '0';
                    load <= '1';
                    state <= IDLE;
                else
                    load <= '1';
                    state <= WRITE_PREPARE;
                    address <= (address + 1);
                end if;
        end case;
    end if;
end process DAC_CONTROLLER_FSM;

end architecture MyHDL;
