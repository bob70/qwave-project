-- File: ft245sync.vhd
-- Generated by MyHDL 0.7
-- Date: Thu May  2 14:59:28 2013



package pck_ft245sync is

    type t_enum_tFtState_1 is (
    IDLE,
    WRITE_PREP,
    READ_PREP,
    WRITE,
    READ
);

end package pck_ft245sync;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_07.all;

use work.pck_ft245sync.all;

entity ft245sync is
    port (
        clk: in std_logic;
        reset: in std_logic;
        rxf: in std_logic;
        txe: in std_logic;
        rd_int: out std_logic;
        wr_int: out std_logic;
        oe_int: out std_logic;
        siwu: out std_logic;
        adbus: inout unsigned(7 downto 0);
        dataIn: in unsigned(7 downto 0);
        dataOut: out unsigned(7 downto 0);
        rw: in std_logic;
        busy: out std_logic;
        dataWaitIn: in std_logic;
        dataWaitOut: out std_logic;
        strobe: in std_logic
    );
end entity ft245sync;
-- FTDI interface:
-- clk - 60MHz clock from FTDI
-- reset - asynchronous reset
-- rxf - IN - When low, there is data available in the FIFO which can be read by driving RD# low. 
--       When in synchronous mode, data is transferred on every clock that RXF# and RD# are both low. 
--       Note that the OE# pin must be driven low at least 1 clock period before asserting RD# low.
-- txe - IN - When low, data can be written into the FIFO by driving WR# low. 
--       When in synchronous mode, data is transferred on every clock that TXE# and WR# are both low.
-- rd - OUT -  Enables the current FIFO data byte to be driven onto D0...D7 when RD# goes low. 
--       The next FIFO data byte (if available) is fetched from the receive FIFO buffer each CLKOUT cycle until RD# goes high.
-- wr - OUT - Enables the data byte on the D0...D7 pins to be written into the transmit FIFO buffer when WR# is low. 
--      The next FIFO data byte is written to the transmit FIFO buffer each CLKOUT cycle until WR# goes high.
-- oe - OUT - Output enable when low to drive data onto D0-7. T
--      his should be driven low at least 1 clock period before driving RD# low to allow for data buffer turn-around.
-- adbus - I/O - D7 to D0 bidirectional FIFO data. This bus is normally output unless OE# is low.
-- Controller interface:
-- dataIn - IN - Data writen from controller
-- dataOut - OUT - Data read from controller
-- rw - IN - data direction 0 read, 1 write
-- busy - OUT - busy flag
-- strobe - IN - strobe of RW flag

architecture MyHDL of ft245sync is

signal adbus_out: unsigned(7 downto 0);
signal state: t_enum_tFtState_1;
signal adbus_drv: unsigned(7 downto 0);

begin


adbus <= adbus_drv;


FT245SYNC_FSM: process (clk, reset) is
begin
    if (reset = '1') then
        state <= IDLE;
        busy <= '1';
        rd_int <= '1';
        wr_int <= '1';
        oe_int <= '1';
        siwu <= '1';
    elsif rising_edge(clk) then
        case state is
            when IDLE =>
                if (strobe = '1') then
                    busy <= '1';
                    if (rw = '1') then
                        state <= WRITE_PREP;
                    else
                        state <= READ_PREP;
                    end if;
                else
                    busy <= '0';
                    state <= IDLE;
                end if;
            when WRITE_PREP =>
                if (txe = '0') then
                    state <= WRITE;
                else
                    state <= WRITE_PREP;
                end if;
            when READ_PREP =>
                if (rxf = '0') then
                    state <= READ;
                    oe_int <= '0';
                else
                    state <= READ_PREP;
                end if;
            when WRITE =>
                if ((txe = '0') and (not to_boolean(dataWaitIn))) then
                    wr_int <= '0';
                else
                    wr_int <= '1';
                    state <= IDLE;
                    busy <= '0';
                end if;
            when others => -- READ
                if (rxf = '0') then
                    if to_boolean(dataWaitIn) then
                        rd_int <= '1';
                    else
                        rd_int <= '0';
                    end if;
                else
                    rd_int <= '1';
                    oe_int <= '1';
                    state <= IDLE;
                    busy <= '0';
                end if;
        end case;
    end if;
end process FT245SYNC_FSM;


FT245SYNC_TX: process (clk) is
begin
    if rising_edge(clk) then
        if ((state = WRITE) or (state = WRITE_PREP)) then
            adbus_out <= dataIn;
        end if;
    end if;
end process FT245SYNC_TX;


FT245SYNC_RX: process (clk) is
begin
    if rising_edge(clk) then
        if ((state = READ) or (state = READ_PREP)) then
            dataOut <= adbus;
        end if;
    end if;
end process FT245SYNC_RX;


FT245SYNC_BUS_DIRECTION: process (adbus_out, rxf) is
begin
    if to_boolean(rxf) then
        adbus_drv <= adbus_out;
    else
        adbus_drv <= (others => 'Z');
    end if;
end process FT245SYNC_BUS_DIRECTION;


FT245SYNC_DATAWAIT: process (reset, state, txe) is
begin
    if (reset = '1') then
        dataWaitOut <= '1';
    else
        case state is
            when IDLE =>
                dataWaitOut <= '1';
            when WRITE =>
                if (txe = '0') then
                    dataWaitOut <= '0';
                else
                    dataWaitOut <= '1';
                end if;
            when others =>
                dataWaitOut <= '1';
        end case;
    end if;
end process FT245SYNC_DATAWAIT;

end architecture MyHDL;
